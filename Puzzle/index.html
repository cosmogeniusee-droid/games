<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ù–µ—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ü–∞–∑–ª Drag & Drop</title>
    <!-- Tailwind CSS CDN –¥–ª—è —Å—Ç–∏–ª–∏–∑–∞—Ü–∏–∏ --><script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        html,body{
            height: 100%;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            height: 100vh; 
            width: 100vw; 
            margin: 0;
            overflow: hidden; 
            /* --- –ó–∞–ø—Ä–µ—â–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –Ω–∞ –≤—Å–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ --- */
            user-select: none; 
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            /* ----------------------------------------------------------------- */
        }
        /* –ì–ª–∞–≤–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Å–µ–≥–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ */
        .full-screen-center {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            padding: 1rem;
        }
        #puzzle-container {
            position: relative;
            max-width: 80vh; 
            max-height: 80vh; 
            aspect-ratio: 1 / 1; 
            border: 5px solid #3b82f6;
            background-color: #e2e8f0; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            /* –†–∞–∑—Ä–µ—à–∞–µ–º –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å —á–∞—Å—Ç–∏ –ø–∞–∑–ª–∞ –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ —Ä–∞–º–∫–∏ –≤–æ –≤—Ä–µ–º—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è */
            overflow: visible; 
        }
        #puzzle-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: visible; 
        }
        .puzzle-piece {
            cursor: grab;
            /* –î–æ–±–∞–≤–ª—è–µ–º –ø–µ—Ä–µ—Ö–æ–¥ –¥–ª—è –ø–ª–∞–≤–Ω–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è –∏ –≤—Ä–∞—â–µ–Ω–∏—è */
            transition: transform 0.5s ease-out, stroke 0.2s, filter 0.2s; 
            stroke: rgba(0,0,0,0.5); 
            stroke-width: 1px;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.2)); 
            transform-origin: center center; /* –í–∞–∂–Ω–æ –¥–ª—è –≤—Ä–∞—â–µ–Ω–∏—è */
        }
        .puzzle-piece.dragging {
            cursor: grabbing;
            filter: drop-shadow(0 8px 10px rgba(0,0,0,0.4));
            z-index: 100; 
            transition: none; /* –û—Ç–∫–ª—é—á–∞–µ–º –ø–ª–∞–≤–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥ –≤–æ –≤—Ä–µ–º—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è */
        }
        .puzzle-piece.solved {
            cursor: default;
            /* –Ø—Ä–∫–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –¥–ª—è —Ä–µ—à–µ–Ω–Ω—ã—Ö —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤ */
            stroke: #22c55e; /* Tailwind green-500 */
            stroke-width: 4px;
            /* –î–æ–±–∞–≤–ª—è–µ–º –ª–µ–≥–∫–∏–π –∑–µ–ª–µ–Ω—ã–π –æ—Ç—Ç–µ–Ω–æ–∫, —á—Ç–æ–±—ã –±—ã–ª–æ –≤–∏–¥–Ω–æ, —á—Ç–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç "–∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω" */
            filter: drop-shadow(0 0 5px rgba(34, 197, 94, 0.5)); 
        }
        .original-overlay {
            opacity: 0.3; 
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
            transition: opacity 0.5s;
        }
    </style>
</head>
<body class="full-screen-center">

    <button id="fullscreen-btn" class="fixed top-4 right-4 bg-white p-2 rounded-full shadow-lg z-50 transition-transform transform hover:scale-110 focus:outline-none">
        <svg id="fullscreen-icon-open" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-maximize">
            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
        </svg>
        <svg id="fullscreen-icon-close" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-minimize hidden">
            <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>
        </svg>
    </button>

    <div class="max-w-4xl w-full bg-white p-8 rounded-xl shadow-2xl flex flex-col items-center justify-center gap-8">
        <div>            
            <!-- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è SVG-–ø–∞–∑–ª–∞. –†–∞–∑–º–µ—Ä—ã –±—É–¥—É—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã JS --><div id="puzzle-container" class="mx-auto rounded-lg relative">
                <svg id="puzzle-svg" viewBox="0 0 700 700" xmlns="http://www.w3.org/2000/svg">
                    <!-- –ó–¥–µ—Å—å –±—É–¥—É—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã SVG --></svg>
            </div>

            <!-- –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∏ –∫–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è --><div class="text-center mt-6">
                <!-- –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –ò–ù–°–¢–†–£–ö–¶–ò–Ø -->
                <div id="message" class="text-xl font-semibold h-8 mb-4 text-green-600">
                    –ù–∞–∂–º–∏—Ç–µ **–ü—Ä–∞–≤—É—é –∫–Ω–æ–ø–∫—É –º—ã—à–∏** (–ü–ö–ú) –∏–ª–∏ **–î–≤–æ–π–Ω–æ–µ –∫–∞—Å–∞–Ω–∏–µ** (—Å–µ–Ω—Å–æ—Ä) –¥–ª—è –ø–æ–≤–æ—Ä–æ—Ç–∞ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞. –ù–∞–∂–º–∏—Ç–µ "–ù–∞—á–∞—Ç—å –∏–≥—Ä—É"!
                </div>
            </div>
        </div>
    </div>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const IMAGE_URL = urlParams.get('pictureUrl') || "https://picinspire.com/uploads/media/default/0001/07/thumb_6565_default_med.jpg"; 
        const sizeParam = parseInt(urlParams.get('size'), 10);
        const GRID_SIZE = (!isNaN(sizeParam) && sizeParam > 1) ? sizeParam : 3; 
        let PUZZLE_DIMENSION; 

        const puzzleSvg = document.getElementById('puzzle-svg');
        const messageElement = document.getElementById('message');
        const puzzleContainer = document.getElementById('puzzle-container');

        // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –≥–µ–æ–º–µ—Ç—Ä–∏–∏ –∏ —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–±–µ–ª–æ–≤ (bleed margin)
        const H_LOCAL_FACTOR = 1/8; // 12.5% –æ—Ç—Å—Ç—É–ø –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –∫—Ä–∞–µ–≤ (–¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–±–µ–ª–æ–≤)
        const H_DEPTH_FACTOR = 1/10; // 10% –≥–ª—É–±–∏–Ω–∞ –≤—ã—Å—Ç—É–ø–æ–≤/–ø–∞–∑–æ–≤

        let pieces = []; 
        let solvedPieces = 0; 
        let isDragging = false;
        let activePiece = null;
        let initialX, initialY, xOffset = 0, yOffset = 0; 
        let pieceSize; // –†–∞–∑–º–µ—Ä –æ–¥–Ω–æ–≥–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞

        // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        const img = new Image();
        img.src = IMAGE_URL;

        /**
         * –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Ä–∞–∑–º–µ—Ä –ø–∞–∑–ª–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–∫—É—â–µ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞.
         */
        function calculatePuzzleDimension() {
            const size = Math.min(window.innerWidth, window.innerHeight) * 0.65;            
            PUZZLE_DIMENSION = Math.max(300, Math.min(size, 1200));
            pieceSize = PUZZLE_DIMENSION / GRID_SIZE;

            puzzleContainer.style.width = `${PUZZLE_DIMENSION}px`;
            puzzleContainer.style.height = `${PUZZLE_DIMENSION}px`;
            puzzleSvg.setAttribute('viewBox', `0 0 ${PUZZLE_DIMENSION} ${PUZZLE_DIMENSION}`);
        }

        function setTransform(xPos, yPos, rotationDeg, el) {
            const rotationCenter = 5*((PUZZLE_DIMENSION / GRID_SIZE) * H_LOCAL_FACTOR) - PUZZLE_DIMENSION/2;
  
            // –û–∫—Ä—É–≥–ª—è–µ–º –í–°–ï –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏ (—É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ç–æ—á–Ω–æ—Å—Ç—å –¥–æ 4 –∑–Ω–∞–∫–æ–≤)
            const precision = 10000;
            const roundedXPos = Math.round(xPos * precision) / precision;
            const roundedYPos = Math.round(yPos * precision) / precision;
           

            el.setAttribute('transform', 
                `translate(${roundedXPos},${roundedYPos}) rotate(${rotationDeg}, ${rotationCenter}, ${rotationCenter})`
            );

            return { x: roundedXPos, y: roundedYPos };
        }

        /**
         * –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç —Ñ—Ä–∞–≥–º–µ–Ω—Ç –Ω–∞ 90 –≥—Ä–∞–¥—É—Å–æ–≤ (–ø–æ —Ü–∏–∫–ª—É).
         */
        function rotatePiece(pieceElement) {
            // –ó–∞–ø—Ä–µ—Ç–∏—Ç—å –≤—Ä–∞—â–µ–Ω–∏–µ, –µ—Å–ª–∏ —Ñ—Ä–∞–≥–º–µ–Ω—Ç —É–∂–µ —Ä–µ—à–µ–Ω
            if (pieceElement.classList.contains('solved')) return;

            const pieceObj = pieces.find(p => p.element === pieceElement);
            if (!pieceObj) return;
                // –¶–∏–∫–ª: 0 -> 1 -> 2 -> 3 -> 0 (0, 90, 180, 270 –≥—Ä–∞–¥—É—Å–æ–≤)
                pieceObj.rotation = (pieceObj.rotation + 1) % 4; 
                const rotationDeg = pieceObj.rotation * 90;

                // –ü—Ä–∏–º–µ–Ω—è–µ–º transform –∏ —Å—Ä–∞–∑—É –∂–µ –æ–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–∫—Ä—É–≥–ª–µ–Ω–Ω—ã–º–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏
                const { x, y } = setTransform(pieceObj.currentX, pieceObj.currentY, rotationDeg, pieceElement);
                
                // –≠—Ç–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ —Å–ª–µ–¥—É—é—â–∏–π –ø–æ–≤–æ—Ä–æ—Ç –∏–ª–∏ drag –Ω–∞—á–Ω–µ—Ç—Å—è —Å –∏–¥–µ–∞–ª—å–Ω–æ —Å—Ç–∞–±–∏–ª—å–Ω–æ–π —Ç–æ—á–∫–∏
                pieceObj.currentX = x;
                pieceObj.currentY = y;
        }
        
        /**
         * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç SVG-—Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã –ø–∞–∑–ª–∞ –∏ —Å–æ–∑–¥–∞–µ—Ç –¥–ª—è –Ω–∏—Ö —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –∑–∞–ª–∏–≤–∫–∏.
         */
        function initializePuzzle() {
            puzzleSvg.innerHTML = ''; 
            pieces = [];
            solvedPieces = 0;
            // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏
            messageElement.textContent = "–ù–∞–∂–º–∏—Ç–µ –ü—Ä–∞–≤—É—é –∫–Ω–æ–ø–∫—É –º—ã—à–∏ (–ü–ö–ú) –∏–ª–∏ –î–≤–æ–π–Ω–æ–µ –∫–∞—Å–∞–Ω–∏–µ (—Å–µ–Ω—Å–æ—Ä) –¥–ª—è –ø–æ–≤–æ—Ä–æ—Ç–∞ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞. –ù–∞–∂–º–∏—Ç–µ '–ù–∞—á–∞—Ç—å –∏–≥—Ä—É'!";
            
            const H_LOCAL = pieceSize * H_LOCAL_FACTOR; // –ó–∞—â–∏—Ç–Ω—ã–π –æ—Ç—Å—Ç—É–ø –¥–ª—è –∫–æ–Ω—Ç—É—Ä–∞
            
            const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            puzzleSvg.appendChild(defs);

            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const row = Math.floor(i / GRID_SIZE);
                const col = i % GRID_SIZE;

                const x = col * pieceSize;
                const y = row * pieceSize;

                // 1. –°–æ–∑–¥–∞–Ω–∏–µ pattern –¥–ª—è —ç—Ç–æ–≥–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞
                const patternId = `imgPattern-${i}`;
                const piecePattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
                piecePattern.setAttribute('id', patternId);
                piecePattern.setAttribute('patternUnits', 'userSpaceOnUse'); 
                piecePattern.setAttribute('width', PUZZLE_DIMENSION);
                piecePattern.setAttribute('height', PUZZLE_DIMENSION);
                
                // 2. –°–º–µ—â–µ–Ω–∏–µ –∏ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–±–µ–ª–æ–≤ (bleed margin)
                const pieceImage = document.createElementNS("http://www.w3.org/2000/svg", "image");
                pieceImage.setAttribute('href', IMAGE_URL);
                pieceImage.setAttribute('x', -(x)); 
                pieceImage.setAttribute('y', -(y)); 
                pieceImage.setAttribute('width', PUZZLE_DIMENSION + 2 * H_LOCAL);
                pieceImage.setAttribute('height', PUZZLE_DIMENSION + 2 * H_LOCAL);

                piecePattern.appendChild(pieceImage);
                defs.appendChild(piecePattern);
                
                // 3. –°–æ–∑–¥–∞–Ω–∏–µ path 
                const pathData = generatePuzzlePiecePath(row, col, pieceSize, GRID_SIZE, H_LOCAL);
                
                const piece = document.createElementNS("http://www.w3.org/2000/svg", "path");
                piece.setAttribute('d', pathData);
                piece.setAttribute('fill', `url(#${patternId})`); 
                piece.setAttribute('class', 'puzzle-piece');
                
                // –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã –Ω–∞—Ö–æ–¥—è—Ç—Å—è –Ω–∞ —Å–≤–æ–∏—Ö –º–µ—Å—Ç–∞—Ö (rotation = 0deg)
                const { x: initialXPos, y: initialYPos } = setTransform(x - H_LOCAL, y - H_LOCAL, 0, piece);
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ (—É–∂–µ —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–æ –Ω–∞ H_LOCAL)
                piece.dataset.originalX = initialXPos; 
                piece.dataset.originalY = initialYPos;
                piece.dataset.index = i;
                // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –ø–æ–ª–µ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –¥–≤–æ–π–Ω–æ–≥–æ –∫–∞—Å–∞–Ω–∏—è
                piece.lastTapTime = 0; 

                pieces.push({
                    element: piece,
                    originalX: initialXPos, 
                    originalY: initialYPos,
                    currentX: initialXPos, 
                    currentY: initialYPos,
                    rotation: 0, // 0 = 0deg, 1 = 90deg, 2 = 180deg, 3 = 270deg
                    isSolved: false,
                });

                // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
                piece.addEventListener('mousedown', dragStart);
                piece.addEventListener('touchstart', dragStart);
                
                // !!! –£–î–ê–õ–ï–ù contextmenu listener —Å –∫–∞–∂–¥–æ–π piece, —Ç–µ–ø–µ—Ä—å –æ–Ω –≥–ª–æ–±–∞–ª—å–Ω—ã–π –Ω–∞ puzzleSvg
                
                puzzleSvg.appendChild(piece);
            }
        }

        /**
         * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç SVG path —Å—Ç—Ä–æ–∫—É –¥–ª—è –æ–¥–Ω–æ–π –ø–ª–∏—Ç–∫–∏ –ø–∞–∑–ª–∞ —Å "–∑—É–±—á–∏–∫–∞–º–∏". (–õ–æ–≥–∏–∫–∞ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
         */
        function generatePuzzlePiecePath(row, col, pieceSize, gridSize, H_LOCAL) {
            const T = pieceSize / 3; 
            const H_DEPTH = pieceSize * H_DEPTH_FACTOR; 
            
            let path = `M ${H_LOCAL},${H_LOCAL}`; 

            const T_PROTRUSION = `l ${T} 0 c ${T/4} ${-H_DEPTH} ${T*3/4} ${-H_DEPTH} ${T} 0 l ${T} 0`; 
            const T_INDENTATION = `l ${T} 0 c ${T/4} ${H_DEPTH} ${T*3/4} ${H_DEPTH} ${T} 0 l ${T} 0`;
            const R_PROTRUSION = `l 0 ${T} c ${H_DEPTH} ${T/4} ${H_DEPTH} ${T*3/4} 0 ${T} l 0 ${T}`; 
            const R_INDENTATION = `l 0 ${T} c ${-H_DEPTH} ${T/4} ${-H_DEPTH} ${T*3/4} 0 ${T} l 0 ${T}`; 
            const B_PROTRUSION = `l ${-T} 0 c ${-T/4} ${H_DEPTH} ${-T*3/4} ${H_DEPTH} ${-T} 0 l ${-T} 0`; 
            const B_INDENTATION = `l ${-T} 0 c ${-T/4} ${-H_DEPTH} ${-T*3/4} ${-H_DEPTH} ${-T} 0 l ${-T} 0`; 
            const L_PROTRUSION = `l 0 ${-T} c ${-H_DEPTH} ${-T/4} ${-H_DEPTH} ${-T*3/4} 0 ${-T} l 0 ${-T}`; 
            const L_INDENTATION = `l 0 ${-T} c ${H_DEPTH} ${-T/4} ${H_DEPTH} ${-T*3/4} 0 ${-T} l 0 ${-T}`; 

            if (row === 0) { path += ` l ${pieceSize},0`; } else { path += (col % 2 === 0) ? T_PROTRUSION : T_INDENTATION; }
            if (col === gridSize - 1) { path += ` l 0,${pieceSize}`; } else { path += (row % 2 === 0) ? R_PROTRUSION : R_INDENTATION; }
            if (row === gridSize - 1) { path += ` l ${-pieceSize},0`; } else { path += (col % 2 === 0) ? B_INDENTATION : B_PROTRUSION; }
            if (col === 0) { path += ` l 0,${-pieceSize}`; } else { path += (row % 2 === 0) ? L_INDENTATION : L_PROTRUSION; }

            path += ` L ${H_LOCAL},${H_LOCAL} Z`; 
            return path;
        }

        /**
         * –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ—Ç –∏ —Å–ª—É—á–∞–π–Ω—ã–º –æ–±—Ä–∞–∑–æ–º —Ä–∞–∑–º–µ—â–∞–µ—Ç —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã –ø–∞–∑–ª–∞ —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π.
         */
        function shufflePieces() {
            const usedPositions = new Set();
            pieces.forEach(p => {
                let randomX, randomY;
                let overlap = true;
                
                const pieceDim = PUZZLE_DIMENSION / GRID_SIZE; 
                
                while(overlap) {
                    // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è
                    const shuffleRange = PUZZLE_DIMENSION * 1.5; 
                    randomX = Math.random() * (shuffleRange - pieceDim) - (shuffleRange - PUZZLE_DIMENSION) / 2;
                    randomY = Math.random() * (shuffleRange - pieceDim) - (shuffleRange - PUZZLE_DIMENSION) / 2;
                    overlap = false;

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –Ω–∞–∫–ª–∞–¥—ã–≤–∞–µ—Ç—Å—è –ª–∏ –Ω–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è –Ω–∞ —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–µ
                    for (let pos of usedPositions) {
                        if (Math.abs(randomX - pos.x) < pieceDim * 0.8 && Math.abs(randomY - pos.y) < pieceDim * 0.8) {
                            overlap = true;
                            break;
                        }
                    }
                }
                usedPositions.add({x: randomX, y: randomY});

                // –ü—Ä–∏—Å–≤–∞–∏–≤–∞–µ–º —Å–ª—É—á–∞–π–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ: 0, 90, 180 –∏–ª–∏ 270 –≥—Ä–∞–¥—É—Å–æ–≤
                p.rotation = Math.floor(Math.random() * 4); 
                const rotationDeg = p.rotation * 90;

                // –ü—Ä–∏–º–µ–Ω—è–µ–º transform –∏ —Å—Ä–∞–∑—É –∂–µ –æ–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–∫—Ä—É–≥–ª–µ–Ω–Ω—ã–º–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏
                const { x, y } = setTransform(randomX, randomY, rotationDeg, p.element); 
                
                p.currentX = x; // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—É—â–µ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ
                p.currentY = y;
                
                p.isSolved = false;
                p.element.classList.remove('solved'); 
            });
            messageElement.textContent = "–ü–∞–∑–ª –ø–µ—Ä–µ–º–µ—à–∞–Ω! –ü—Ä–∞–≤—É—é –∫–Ω–æ–ø–∫—É –º—ã—à–∏ –∏–ª–∏ –î–≤–æ–π–Ω–æ–µ –∫–∞—Å–∞–Ω–∏–µ, —á—Ç–æ–±—ã –ø–æ–≤–µ—Ä–Ω—É—Ç—å. –°–æ–±–∏—Ä–∞–π—Ç–µ!";
        }

        /**
         * –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ Drag & Drop.
         */
        function dragStart(e) {
            if (e.target.classList.contains('solved') || e.target.tagName !== 'path') {
                return; 
            }
            
            // --- –í—Ä–∞—â–µ–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é –ü–†–ê–í–û–ô –ö–ù–û–¢–ö–ò –ú–´–®–ò (e.button === 2) ---
            if (e.type === "mousedown" && e.button === 2) {
                e.preventDefault(); // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –Ω–∞—á–∞–ª–æ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
                rotatePiece(e.target);
                return;
            }
            
            // --- –û–ë–†–ê–ë–û–¢–ö–ê –î–í–û–ô–ù–û–ì–û –ö–ê–°–ê–ù–ò–Ø (Touch Double Tap) ---
            if (e.type === "touchstart") {
                const touchPiece = e.target;
                const now = Date.now();
                const timeSinceLastTap = now - (touchPiece.lastTapTime || 0);
                
                // –ï—Å–ª–∏ –¥–≤–æ–π–Ω–æ–µ –∫–∞—Å–∞–Ω–∏–µ –ø—Ä–æ–∏–∑–æ—à–ª–æ –±—ã—Å—Ç—Ä–æ (–º–µ–Ω–µ–µ 300 –º—Å)
                if (timeSinceLastTap < 300 && timeSinceLastTap > 0) {
                    e.preventDefault(); // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –Ω–∞—á–∞–ª–æ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è –∏ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ
                    rotatePiece(touchPiece);
                    touchPiece.lastTapTime = 0; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Ç—Ä–æ–π–Ω–æ–≥–æ –∫–∞—Å–∞–Ω–∏—è
                    return; 
                }
                
                touchPiece.lastTapTime = now; // –ó–∞–ø–æ–º–∏–Ω–∞–µ–º –≤—Ä–µ–º—è –ø–µ—Ä–≤–æ–≥–æ –∫–∞—Å–∞–Ω–∏—è
            }
            // --- –ö–û–ù–ï–¶ –õ–û–ì–ò–ö–ò –î–í–û–ô–ù–û–ì–û –ö–ê–°–ê–ù–ò–Ø ---

            // –ï—Å–ª–∏ —ç—Ç–æ –ª–µ–≤–∞—è –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏ (e.button === 0) –∏–ª–∏ –æ–¥–∏–Ω–æ—á–Ω–æ–µ –∫–∞—Å–∞–Ω–∏–µ, –Ω–∞—á–∏–Ω–∞–µ–º drag
            activePiece = e.target;
            isDragging = true;
            activePiece.classList.add('dragging');

            // –ü–µ—Ä–µ–º–µ—â–∞–µ–º —Ñ—Ä–∞–≥–º–µ–Ω—Ç –≤ –∫–æ–Ω–µ—Ü SVG –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞–¥ –æ—Å—Ç–∞–ª—å–Ω—ã–º–∏
            puzzleSvg.appendChild(activePiece); 

            // –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—É—â–∏–µ translate –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ –æ–±—ä–µ–∫—Ç–∞
            const currentPieceObj = pieces.find(p => p.element === activePiece);
            if (currentPieceObj) {
                // currentX/Y —É–∂–µ —Å–æ–¥–µ—Ä–∂–∞—Ç –æ–∫—Ä—É–≥–ª–µ–Ω–Ω—ã–µ, —Å—Ç–∞–±–∏–ª—å–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ drag/rotate
                xOffset = currentPieceObj.currentX;
                yOffset = currentPieceObj.currentY;
            }

            if (e.type === "touchstart") {
                initialX = e.touches[0].clientX;
                initialY = e.touches[0].clientY;
            } else {
                initialX = e.clientX;
                initialY = e.clientY;
            }
        }

        function drag(e) {
            if (isDragging && activePiece) {
                e.preventDefault();

                let clientX, clientY;
                if (e.type === "touchmove") {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                const deltaX = clientX - initialX;
                const deltaY = clientY - initialY;
                
                const svgRect = puzzleSvg.getBoundingClientRect();
                
                const currentPieceObj = pieces.find(p => p.element === activePiece);
                const rotationDeg = currentPieceObj ? currentPieceObj.rotation * 90 : 0;

                // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–º–µ—â–µ–Ω–∏–µ –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã SVG
                const currentX = xOffset + (deltaX * PUZZLE_DIMENSION / svgRect.width);
                const currentY = yOffset + (deltaY * PUZZLE_DIMENSION / svgRect.height);
                
                // setTransform –æ–∫—Ä—É–≥–ª—è–µ—Ç –∏ –ø—Ä–∏–º–µ–Ω—è–µ—Ç
                const { x: newX, y: newY } = setTransform(currentX, currentY, rotationDeg, activePiece);
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞ –æ–∫—Ä—É–≥–ª–µ–Ω–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏.
                currentPieceObj.currentX = newX;
                currentPieceObj.currentY = newY;
            }
        }

        function dragEnd(e) {
            if (isDragging && activePiece) {
                const snapThreshold = 30; 
                const currentPieceObj = pieces.find(p => p.element === activePiece);
                
                if (currentPieceObj) {
                    const rotationDeg = currentPieceObj.rotation * 90;

                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â–∏–µ —Å—Ç–∞–±–∏–ª—å–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –±—ã–ª–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –≤ drag()
                    const finalX = currentPieceObj.currentX; 
                    const finalY = currentPieceObj.currentY;

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Ç–µ–∫—É—â–∞—è –ø–æ–∑–∏—Ü–∏—è –±–ª–∏–∑–∫–æ –∫ Solved-–ø–æ–∑–∏—Ü–∏–∏
                    const diffX = Math.abs(finalX - currentPieceObj.originalX);
                    const diffY = Math.abs(finalY - currentPieceObj.originalY);

                    // –£—Å–ª–æ–≤–∏–µ —Ä–µ—à–µ–Ω–∏—è: –ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –ò –Ω—É–ª–µ–≤–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ
                    if (diffX < snapThreshold && diffY < snapThreshold && currentPieceObj.rotation === 0) {
                        // –ó–∞—â–µ–ª–∫–∏–≤–∞–µ–º —Ñ—Ä–∞–≥–º–µ–Ω—Ç –Ω–∞ –º–µ—Å—Ç–æ (–∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ, —Å—Ç–∞–±–∏–ª—å–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã)
                        const { x, y } = setTransform(currentPieceObj.originalX, currentPieceObj.originalY, 0, activePiece);

                        // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—É—â–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –æ–±—ä–µ–∫—Ç–∞ (solved position)
                        currentPieceObj.currentX = x;
                        currentPieceObj.currentY = y;
                        currentPieceObj.isSolved = true;
                        activePiece.classList.add('solved');
                        solvedPieces++;
                        messageElement.textContent = `–°–æ–±—Ä–∞–Ω–æ: ${solvedPieces} –∏–∑ ${pieces.length}`;

                        if (solvedPieces === pieces.length) {
                            messageElement.textContent = "üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã —Å–æ–±—Ä–∞–ª–∏ –∫–∞—Ä—Ç–∏–Ω–∫—É! üéâ";
                            
                            const pieces = puzzleSvg.getElementsByClassName('solved');
                            Array.from(pieces).forEach(p=>p.classList.remove('solved'));
                        }
                    } else {
                        // –ï—Å–ª–∏ –Ω–µ –ø–æ–ø–∞–ª, —Ñ–∏–∫—Å–∏—Ä—É–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ –æ–∫—Ä—É–≥–ª–µ–Ω–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –∫–∞–∫ –Ω–æ–≤–æ–µ —Ç–µ–∫—É—â–µ–µ
                        const { x, y } = setTransform(finalX, finalY, rotationDeg, activePiece);
                        currentPieceObj.currentX = x;
                        currentPieceObj.currentY = y;
                    }
                }
            }
            
            isDragging = false;
            if (activePiece) {
                activePiece.classList.remove('dragging');
            }
            activePiece = null;
        }

        // –û–±—â–∏–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –¥–ª—è –≤—Å–µ–≥–æ –æ–∫–Ω–∞ –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ–≥–æ Drag & Drop
        window.addEventListener('mousemove', drag);
        window.addEventListener('mouseup', dragEnd);
        window.addEventListener('touchmove', drag);
        window.addEventListener('touchend', dragEnd);
        
        // --- –ù–û–í–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –ø–æ—è–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –º–µ–Ω—é –Ω–∞ –≤—Å–µ–π SVG-–æ–±–ª–∞—Å—Ç–∏ ---
        window.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        // -----------------------------------------------------------------------------------

        calculatePuzzleDimension();
        initializePuzzle(); 
        setTimeout(shufflePieces, 100); 

        // --- Fullscreen Logic ---
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const openIcon = document.getElementById('fullscreen-icon-open');
        const closeIcon = document.getElementById('fullscreen-icon-close');

        function toggleFullscreen() {
            if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.msRequestFullscreen) {
                    document.documentElement.msRequestFullscreen();
                } else if (document.documentElement.mozRequestFullScreen) {
                    document.documentElement.mozRequestFullScreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
            }       
            setTimeout(()=>{
                calculatePuzzleDimension();
                initializePuzzle(); 
                setTimeout(shufflePieces, 100); 
            }, 100);            
        }

        fullscreenBtn.addEventListener('click', toggleFullscreen);

        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                openIcon.classList.add('hidden');
                closeIcon.classList.remove('hidden');
            } else {
                openIcon.classList.remove('hidden');
                closeIcon.classList.add('hidden');
            }
        });
        // --- End Fullscreen Logic ---
    </script>
</body>
</html>